#!/usr/bin/env python3

import sys


def read_table(fin=sys.stdin):
    table = []
    while True:
        line = fin.readline().rstrip('\r\n')
        if len(line) == 0:
            break
        row = [c.strip() for c in line.split('&')]
        table.append(row)

    col_count = max(map(lambda r: len(r), table))
    for r in table:
        while len(r) < col_count:
            r.append('')
    widths = [[len(c) for c in r] for r in table]
    max_widths = [0]*col_count

    for r in table:
        for i, c in enumerate(r):
            max_widths[i] = max(len(c), max_widths[i])

    return (table, col_count, max_widths)


def print_row(row, widths, aligns, fout=sys.stdout):
    print(' | '.join(['{:{align}{width}}'.format(
        c, width=widths[i], align=aligns[i]) for i, c in enumerate(row)]),
        file=fout)


def print_table(table, cols, widths, aligns, header=True, fout=sys.stdout):
    width = sum(widths) + 3*(cols-1)
    if header:
        print_row(table[0], widths, aligns, fout)
        print('-+-'.join(['-'*w for w in widths]), file=fout)
        table = table[1:]

    for r in table:
        print_row(r, widths, aligns, fout)


def main():
    table, col_count, widths = read_table()
    aligns = ['^']*col_count
    print_table(table, col_count, widths, aligns)


if __name__ == '__main__':
    import argparse

    parser = argparse.ArgumentParser(
            description='Generate an text table from an ampersand (&) seperated string')

    parser.add_argument('-H', '--header',
            help='Treat the first row as a header for the columns',
            action='store_true')
    parser.add_argument('-a', '--align',
            help='A list of alignment flags (l, c, r) for each column listed in order',
            nargs='+')
    parser.add_argument('-i', '--input',
            help='Read the table descriptor from the file INPUT',
            nargs=1)
    parser.add_argument('-o', '--output',
            help='Write the generated table to the file OUTPUT',
            nargs=1)
    
    args = parser.parse_args()

    if args.input:
        fin = open(args.input[0], 'r')
    else:
        fin = sys.stdin

    if args.output:
        fout = open(args.output[0], 'w')
    else:
        fout = sys.stdout

    table, col_count, widths = read_table(fin)

    if args.align:
        align = list(map(lambda k: {
            'l': '<',
            'r': '>',
            'c': '^'
        }[k], args.align))
    else:
        align = ['<']*col_count

    if len(align) != col_count:
        if args.input:
            fin.close()
        if args.output:
            fout.close()
        parser.error('Number of columns does not match number of alignment values')

    print_table(table, col_count, widths, align, args.header, fout)

    if args.input:
        fin.close()
    if args.output:
        fout.close()

